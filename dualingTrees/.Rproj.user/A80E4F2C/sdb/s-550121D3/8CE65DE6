{
    "collab_server" : "",
    "contents" : "\n\n## To Do:\n##   test with sim data\n##   save data. Maybe shuffle values?\n##   write tests\n##   gh\n\nplot_trees <- function(trees_list,              # trees_list = OUT  # list from input_trees()\n                       pn_cols = c('cornflowerblue', 'tomato'),   # colors for positive and negative, resp.\n                       x_tree_col = 'gray30',   # must still add in cols for diff groups.\n                       y_tree_col = 'gray30',   # must still add in cols for diff groups.\n                       x_type_cols = 'gray30',      # vector of length types. see output from input function\n                       y_type_cols = 'gray30',      # vector of length types. see output from input function\n                       x_bar_axis_offset = 0,\n                       y_bar_axis_offset = 0,\n                       pdf_filename = NULL,     # pdf_filename = 'test.pdf'\n                       png_filename = NULL,     # png_filename = 'test.png'\n                       w_inches = 11,\n                       h_inches = 11) {\n\n\n  # require(ape)\n  ## unpack trees_list\n  x_tree         <- trees_list$x_tree\n  y_tree         <- trees_list$y_tree\n  x_ave_resp     <- trees_list$x_ave_resp\n  y_ave_resp     <- trees_list$y_ave_resp\n  mat            <- trees_list$mat\n  nmat           <- trees_list$nmat\n  mat_cex        <- trees_list$mat_cex\n  mat_pn         <- trees_list$mat_pn\n  full_dat       <- trees_list$full_dat\n  group_response <- trees_list$group_response\n  count          <- trees_list$count\n\n\n  ## colors for positive and negative responses.\n  ## test for whether there are two.\n  ## output table of colors for user check.\n  if(length(pn_cols) != 2) {\n    stop('Make sure you have 2 colors as `pn_cols`\n          (one for positive and one for negative)')}\n  cols_pn <- data.frame(cols=c(pn_cols, 'transparent'),\n                        values = c(1, -1, 0),\n                        responses = c('positive', 'negative', 'zero'))\n  cat('\\n\\nHere are the positive and negative colors: \\n')\n  print(cols_pn[, -2])\n\n  ## Colors for x-axis types\n  if(!is.null(x_ave_resp$type)) {\n    if(!is.null(x_type_cols)) {\n      if(length(x_type_cols) == dim(table(x_ave_resp$type))) {\n        xtc <- data.frame(types = levels(x_ave_resp$type),\n                          cols = x_type_cols)\n      } else {\n        stop('Make sure you supplied the right number of colors for x types.\\n')\n      }\n    }\n    ## assign colors\n    x_ave_resp$type_col <- xtc$cols[match(x_ave_resp$type, xtc$types)]\n    ## output for user\n    cat('\\n\\nHere are the colors used for x types: \\n')\n    print(xtc)\n    type <- TRUE\n  } else type <- FALSE\n\n  ## Colors for y-axis types\n  if(!is.null(y_ave_resp$type)) {\n    if(!is.null(y_type_cols)) {\n      if(length(y_type_cols) == dim(table(y_ave_resp$type))) {\n        ytc <- data.frame(types = levels(y_ave_resp$type),\n                          cols = y_type_cols)\n      } else {\n        stop('Make sure you supplied the right number of colors for y types.\\n')\n      }\n    }\n    ## assign colors\n    y_ave_resp$type_col <- ytc$cols[match(y_ave_resp$type, ytc$types)]\n    ## output for user\n    cat('\\n\\nHere are the colors used for y types: \\n')\n    print(ytc)\n    type <- TRUE\n  } else type <- FALSE\n\n  if(!is.null(pdf_filename)) {\n    grDevices::pdf(pdf_filename,\n                   width = w_inches, height = h_inches)\n    dev <- TRUE\n  } else\n    if(!is.null(png_filename)) {\n      grDevices::png(png_filename,\n                     width = w_inches, height = h_inches,\n                     units = 'in', res = 300)\n      dev <- TRUE\n    } else dev <- FALSE\n\n  layout(matrix(c(1, 2, 3,\n                  4, 5, 6,\n                  7, 8, 9),\n                nrow = 3,\n                ncol = 3),\n         widths = c(1, 4, 1.5),\n         heights = c(1, 6.5, 1.5))\n\n\n  #########################\n  ## 1: blank top left corner\n  #########################\n  par(mar = c(0, 0, 0, 0))\n  blank_plot()\n\n\n  if(type) {\n    ## legend for interaction type colors\n    legend('bottomright',\n           legend = ytc$types,\n           pch = 15,\n           col = ytc$cols %>% as.character,\n           y.intersp = 0.85,\n           pt.cex = 1.6,\n           cex = 1.2,\n           text.col = 'gray40',\n           bg = 'gray99',\n           box.col = 'transparent')\n  }\n\n  #########################\n  ## 2: y_axis tree tree\n  #########################\n  par(mar = c(0, 0, 0, 0))\n  ape::plot.phylo(y_tree,\n                  show.tip.label = FALSE,\n                  no.margin = TRUE,\n                  use.edge.length = FALSE,\n                  edge.col = 'gray50',\n                  edge.width = .5)\n  if(!is.null(y_tree$label_nodes)) {\n    ape::nodelabels(y_tree$label_nodes,\n                    bg = 'white',\n                    adj = 1,\n                    frame = 'none')\n  }\n  ## Colored bars at tree tips\n  u <- par()$usr\n  bx1 <- (u[2] - u[1]) * .9\n  bx2 <- u[2]\n  # print(bx1); print(bx2)\n\n  if(type) {\n    type_cols <-\n      y_ave_resp[y_tree$tip.label, 'type_col'] %>%\n      as.character\n  } else type_cols <- y_type_cols\n  segments(rep(bx1, nrow(mat)),\n           1:nrow(mat),\n           rep(bx2, nrow(mat)),\n           1:nrow(mat),\n           col = type_cols,\n           lwd = 2,\n           lend = 'square')\n\n\n\n  #########################\n  ## 3: blank bottom left\n  #########################\n  blank_plot()\n\n  #########################\n  ## 4: top x_axis tree\n  #########################\n  if(length(x_tree_col) > 1) {\n    if(length(x_tree_col) != length(x_tree$edge.length)) {\n      stop('Make sure x_tree_col is either length=1 or length=edge.length')\n    }\n  }\n  ape::plot.phylo(x_tree,\n                  show.tip.label = FALSE,\n                  no.margin = TRUE,\n                  direction = 'downwards',\n                  edge.color = x_tree_col,\n                  edge.width = 2,\n                  use.edge.length = FALSE)\n\n  ## Colored bars at tree tips\n  u <- par()$usr\n  by1 <- u[3] + ((u[4] - u[3]) * .065)\n  by2 <- u[3]\n  # print(u); print(by1); print(by2)\n\n  if(type) {\n    type_cols <-\n      x_ave_resp[x_tree$tip.label, 'type_col'] %>%\n      as.character\n  } else type_cols <- x_type_cols\n  segments(1:ncol(mat),\n           rep(by1, ncol(mat)),\n           1:ncol(mat),\n           rep(by2, ncol(mat)),\n           col=type_cols,\n           lwd = 2,\n           lend = 'square')\n\n\n  #########################\n  ## 5: central interaction matrix\n  #########################\n  par(mar = c(0, 0, 0, 0))\n  blank_plot(x.lim = c(1, ncol(mat)),\n             y.lim = c(1, nrow(mat)),\n             x.axs = 'r',\n             y.axs = 'r')\n  u <- par()$usr\n  rect(u[1],\n       u[3],\n       u[2],\n       u[4],\n       col = 'gray99',\n       border = 'transparent')\n  abline(h = c(1:nrow(mat)),\n         col = 'gray70',\n         lwd = .1)\n  abline(v = c(1:ncol(mat)),\n         col = 'gray70',\n         lwd = .1)\n\n  ## plot points as semitransparent and scaled by responses\n  ## then add subtle gray points on top.\n  if(count) { mat <- nmat }\n  for(i in 1:ncol(mat)) {\n    cols <- cols_pn$cols[match(mat_pn[, i], cols_pn$values)]\n    points(rep(i, nrow(mat_cex)),\n           1:nrow(mat_cex),\n           pch = 16,\n           col = scales::alpha(as.character(cols), .5),\n           cex = mat_cex[, i])\n    points(rep(i, nrow(mat_cex)),\n           1:nrow(mat_cex),\n           pch = 16,\n           col = 'gray40',\n           cex = ((mat_cex[, i]>0) + 0) * 0.3)\n  }\n\n  #########################\n  ## 6: fungal names bottom center\n  #########################\n  if(count) {\n    v <- x_ave_resp[colnames(mat), 'count_resp']\n  } else if(!is.null(x_ave_resp$response_x_bars)) {\n    v <- x_ave_resp[colnames(mat), 'response_x_bars']\n  } else {\n    v <- x_ave_resp[colnames(mat), 'ave_resp_abs']\n  }\n  v_max <- (max(v) * 2)\n  blank_plot(x.lim = c(1, ncol(mat)),\n             x.axs = 'r')\n  cols <- cols_pn$cols[match(x_ave_resp$x_pn, cols_pn$values)] %>% as.character\n  segments((1:ncol(mat)),\n           rep(1, ncol(mat)),\n           (1:ncol(mat)),\n           1 - (v / v_max),\n           col = cols,\n           lwd = 4,\n           lend = 'square')\n  ## white grid lines.\n  ax1 <- pretty(v)\n  lax2 <- ((length(ax1)*5)-4)\n  ax2 <- seq(ax1[1],\n             ax1[length(ax1)],\n             length = lax2)\n  abline(h = (1-(ax1/v_max)),\n         col = 'white',\n         lwd = .6)\n  text((1:ncol(mat)) - 0.6,\n       0.97 - v / v_max,\n       x_tree$tip.label,\n       srt = 270,\n       pos = 4,\n       cex = .9,\n       col = cols)\n  par(xpd = TRUE,\n      col.axis = 'gray50',\n      fg = 'gray50')\n  ## axis for barplot.\n  axis(4, at = (1-(ax2/v_max)),\n       labels = FALSE,\n       line = -1.5 + x_bar_axis_offset,\n       col = 'gray50',\n       col.ticks = 'gray50',\n       tck = -.01)\n  axis(4, at = (1-(ax1/v_max)),\n       labels = FALSE,\n       line = -1.5 + x_bar_axis_offset,\n       col = 'gray50',\n       col.ticks = 'gray50',\n       tck = -.03,\n       las = 1)\n  axis(4, at = (1-(ax1/v_max)),\n       labels = ax1,\n       line = -1.8 + x_bar_axis_offset,\n       col = 'gray50',\n       col.ticks = 'gray50',\n       tck = 0,\n       lwd = 0,\n       las = 1)\n\n  ## 7: blank top right\n  blank_plot()\n\n\n  ## 8: plant names right middle\n  # print(cbind(row.names(y_ave_resp), row.names(mat)))\n  if(count) {\n    v <- y_ave_resp[row.names(mat), 'count_resp']\n  } else if(!is.null(y_ave_resp$response_y_bars)) {\n    v <- y_ave_resp[row.names(mat), 'bars_resp_abs']\n  } else {\n    v <- y_ave_resp[row.names(mat), 'ave_resp_abs']\n  }\n  v_max <- max(y_ave_resp$ave_resp_abs) * 1.5\n  par(mar = c(0, 0, 0, 1))\n  blank_plot(y.lim = c(1, nrow(mat)),\n             y.axs = 'r')\n  cols <- cols_pn$cols[match(y_ave_resp$y_pn, cols_pn$values)] %>% as.character\n  segments(rep(0, nrow(mat)),\n           (1:nrow(mat)),\n           v / v_max,\n           (1:nrow(mat)),\n           col = cols,\n           lwd = 2,\n           lend = 'square')\n\n  ## white grid lines.\n  ax1 <- pretty(v)\n  lax2 <- ((length(ax1)*5)-4)\n  ax2 <- seq(ax1[1], ax1[length(ax1)], length = lax2)\n  # print(v)\n  # print(range(v))\n  # print(ax1)\n  abline(v = (ax1/v_max),\n         col = 'white',\n         lwd = 1.4)\n  abline(v = (ax2/v_max),\n         col = 'white',\n         lwd = .6)\n  text((v / v_max),\n       (1:nrow(mat)),\n       y_ave_resp$y_lab,\n       pos = 4,\n       cex = .9,\n       col = cols)\n  # print(y_ave_resp$y_lab)\n  # print(v / v_max)\n\n  ## axis for barplot.\n  par(xpd = TRUE,\n      col.axis = 'gray50',\n      fg = 'gray50')\n  axis(1, at = (ax2/v_max),\n       labels = FALSE,\n       line = -2 + y_bar_axis_offset,\n       col = 'gray50',\n       col.ticks = 'gray50',\n       tck = -.01)\n  axis(1, at = (ax1/v_max),\n       labels = FALSE,\n       line = -2 + y_bar_axis_offset,\n       col = 'gray50',\n       col.ticks = 'gray50',\n       tck = -.03,\n       las = 1)\n  axis(1, at = (ax1/v_max),\n       labels = ax1,\n       line = -2.3 + y_bar_axis_offset,\n       col = 'gray50',\n       col.ticks = 'gray50',\n       tck = 0,\n       lwd = 0,\n       las = 1)\n\n  # 9 blank with legend\n  par(mar = c(0, 0, 0, 0))\n  cols <- cols_pn$cols[c(1,2)] %>% as.character\n  blank_plot()\n  if(count) {\n    text(.4, .85,\n         'Number of Interactions',\n         cex = 1.2,\n         font = 2)\n    ## Maybe come back to this and add a bubble size legend.\n    # par(lend = 'square')\n    # legend(.22, .8,\n    #                  legend = c('Positive', 'Negative'),\n    #                  lwd = 4,\n    #                  col = cols,\n    #                  bty = 'n',\n    #                  y.intersp = .85,\n    #                  text.col = 'gray40',\n    #                  bg = 'gray97')\n  } else {\n\n    text(.4, .85,\n         'Average Effect Size',\n         cex = 1.2,\n         font = 2)\n    par(lend = 'square')\n    legend(.22, .8,\n           legend = c('Positive', 'Negative'),\n           lwd = 4,\n           col = cols,\n           bty = 'n',\n           y.intersp = .85,\n           text.col = 'gray40',\n           bg = 'gray97')\n  }\n  if(dev) dev.off()\n}\n\n\n\n\n# ##############################################################\n# ## vector for x tree edge colors.\n# x_tree_cols <- rep('gray40', length(test$x_tree$edge.length))\n# x_tree_cols[1:65] <- '#b154a0'\n# x_tree_cols[66:94] <- '#51ad4f'\n# ##############################################################\n#\n#\n#\n# ##############################################################\n# plot_trees(trees_list = test,\n#            pn_cols = c('#409ab1', '#dd1d18'),\n#            x_tree_col = x_tree_cols,\n#            x_type_cols = c('#51ad4f', '#b154a0'),\n#            y_type_cols = c('#51ad4f', '#b154a0', '#5a1b1a'),\n#            pdf_filename = 'test.pdf')\n\n\n\n\n\n",
    "created" : 1494056291972.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1988129454",
    "id" : "8CE65DE6",
    "lastKnownWriteTime" : 1495262085,
    "last_content_update" : 1495262085009,
    "path" : "~/Dropbox (Personal)/R_stuff/dualingTrees-pkg/dualingTrees/R/plot_trees.R",
    "project_path" : "R/plot_trees.R",
    "properties" : {
    },
    "relative_order" : 15,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
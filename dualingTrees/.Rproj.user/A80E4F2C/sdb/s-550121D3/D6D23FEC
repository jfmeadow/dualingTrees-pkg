{
    "collab_server" : "",
    "contents" : "\\name{cutGroups}\n\\alias{cutGroups}\n%- Also NEED an '\\alias' for EACH other topic documented here.\n\\title{cutGroups}\n\\description{\nThe second step in the 3-function barcode figure workflow.\n\nTake the \\code{iv} object created during \\code{getIV()} and:\n\\itemize{\n\\item{cut it down into the features that are the most visually diagnostic for each group}\n\\item{order samples into groups accordingly}\n\\item{order abundance for aesthetics}\n\\item{highlight a product that overlaps with other groups, if requested}\n\\item{highlight the envrironment from which the product originated, if requested}\n\\item{output datasets that are used to make a final plot}\n}\n\nThe output is a complex list that is used in the \\code{makeBarcodePlot()} function.\n\nThis function is fast, so it might make sense to chain it with the third function (\\code{makeBarcodePlot()}) for quick iteration. However, don't combine it with the first function (\\code{getIV}) since that one is painfully slow and generates a boring standard output. Examples at the bottom.\n\n}\n\\usage{\ncutGroups(iv,\n          relfrq_self = 0.7,\n          relfrq_others = 0.4,\n          signif = NULL,\n          product = NULL,\n          product_belongs_to = NULL,\n          feedback = FALSE)\n}\n\n\\arguments{\n  \\item{iv}{\n  The list object output from the \\code{getIV} function.\n\n}\n  \\item{relfrq_self}{\n  A cutoff value (or vector of cutoff values) for the minimum relative frequency a feature needs to have in a given group to be included as a diagnostic feature for plotting. This can either be a single value that is applied uniformly to all groups, or it can be a vector of values (one for each cluster). For example, a feature needs to occur in at least 70\\% (\\code{relfrq_self} = 0.7) of the factory samples to be included as a factory barcode feature. This is always paired with the next, and opposite, argument (\\code{relfrq_others}) to select features.\n\n\n}\n  \\item{relfrq_others}{\n  A cutoff value (or vector of cutoff values) for the maximum relative frequency a feature can occur in non-self groups to be included as a diagnostic feature for in the self group plot. This can either be a single value that is applied uniformly to all groups, or it can be a vector of values (one for each cluster). For example, a feature cannot occur in more than 40\\% (\\code{relfrq_other} = 0.4) of the DC samples to be included as a factory barcode feature. This is always paired with the above, and opposite, argument (\\code{relfrq_self}) to select features.\n\n}\n\n\\item{signif}{\n  Use indicator significance instead of relative frequency. If this is used, all info in \\code{relfrq_self} and \\code{relfrq_others} is ignored. Also, \\code{product_belongs_to} is ignored.\n}\n\n\n  \\item{product}{\n  The character name of a single group to be highlighted as the 'product'. For example, since shoeboxes should contain features overlapping with both factory samples and DC samples, we probably don't want to show how different they are, but rather how much they overlap. Default=NULL, which means that all clusters will be treated as distinct, non-overlapping sets for plotting purposes.\n\n}\n\n  \\item{product_belongs_to}{\n  The character name of a single group to be highlighted as the source of the 'product'. For example, if shoeboxes should contain features overlapping only factory samples and NOT DC samples, we should choose \\code{product_belongs_to='Factory'} and this overlap will be highlighted. Default=NULL, which means that all source clusters will be treated as distinct, and the product cluster will show overlap with all of them. Note that this will likely require an adjustment of the \\code{relfrq_self} and \\code{relfrq_others} parameters because overlapping features will be cut from the non-source environments. This parameter is ignored if \\code{product=NULL}.\n\n}\n\n  \\item{feedback}{\n  There are some feedback mechanisms included here to ensure that everything is lined up as the user intends. The author acknowledges that the ordering of each of the arguements can be confusing, and thus has built in an interactive check system to make sure the user understands what is coming out.\n\n}\n}\n\n\\value{\nLIST:\n\\item{< categories 1:n >}{The first n elements in the returned list correspond to each individual category in the 'cluster' variable used to separate groups. Each is named after its category, and includes relative frequency for each category, as well as the OTU unique identifier for those OTUs that made it past the cutoff values. As a hint, if you really wanted to use this function as a feature selection algorithm, you could just harvest the OTU IDs from here, or you could just use the \\code{dat_trim} element, detailed below. }\n\\item{dat_trim}{The trimmed, ordered feature table. This is ready for plotting, but will be rearranged, depending on the arguments given in the \\code{makeBarcodePlot()} function. }\n\\item{cluster}{The vector of clustering groups. Not necessarily used, but kept for debugging. }\n\\item{sortdf}{A table of sample names, feature counts, and cluster IDs for each sample. This is used for ordering the samples in the plotting function. }\n\\item{product}{Records the original product request. }\n\\item{product_belongs_to}{Records the original product_belongs_to request. }\n\n}\n\n\\author{James Meadow}\n\n\n\n\\seealso{\nSee also \\code{getIV}, \\code{makeBarcodePlot}\n}\n\\examples{\n## generate iv object:\ndata('dat')\ndata('cluster')\ndata('iv')\n\n\\dontrun{iv <- getIV(dat=dat, cluster=cluster)}\n\n#############################\n## generate plotting dataset:\nbarcodes <- cutGroups(iv)\n\n## optionally give each group a different cutoff setting to jive number of features\nbarcodes <- cutGroups(iv,\n                      relfrq_self=c(.5, .5, .8),\n                      relfrq_others=c(.2, .3, .3))\n\n## optionally supply a product to feature rather than distinguish\nbarcodes <- cutGroups(iv,\n                      relfrq_self=.7,\n                      relfrq_others=.3,\n                      product='Shoeboxes')\n\n## optionally supply a source cluster to highlight as well.\n## not that this requires dropping the `relfrq_self` parameter\n##   for the non-source cluster to retain aesthetic balance.\nbarcodes <- cutGroups(iv,\n                      product='Shoeboxes',\n                      product_belongs_to='Factory',\n                      relfrq_self=c(.6, .7, .7),\n                      relfrq_others=.4)\n\n## optionally supply a pvalue cutoff to be used instead of relfrq\nbarcodes <- cutGroups(iv,\n                      signif=.01)\n\n## can also supply a different pvalue for each cluster\nbarcodes <- cutGroups(iv,\n                      signif=c(0.01, 0.01, 0.005))\n\n## or highlight a given product *BUT* `product_belongs_to` will be ignored.\nbarcodes <- cutGroups(iv,\n                      product='Shoeboxes',\n                      signif=c(.01, .005, .01))\n#############################\n\n## then generate barcode figure:\nmakeBarcodePlot(barcodes)\n\n}\n",
    "created" : 1494478955724.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2556298866",
    "id" : "D6D23FEC",
    "lastKnownWriteTime" : 1492202741,
    "last_content_update" : 1492202741,
    "path" : "~/Dropbox (Personal)/R_stuff/barcodes-pkg/barcodes/man/cutGroups.Rd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 17,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_doc"
}
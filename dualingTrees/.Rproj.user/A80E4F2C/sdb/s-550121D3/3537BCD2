{
    "collab_server" : "",
    "contents" : "\ninput_trees <- function(x_tree = NULL,     # x_tree = f_phylo\n                        y_tree = NULL,     # y_tree = p_phylo\n                        x_key = NULL,      # x_key = dat$fungalName\n                        y_key = NULL,      # y_key = dat$plantName\n                        response = NULL,   # response = dat$ei\n                        response_type = NULL,        # category to color tree tips\n                        response_x_bars = NULL,     # must be df with row.names matching tree tips and col 1 as response\n                        response_y_bars = NULL,\n                        count = FALSE,\n                        x_lab_cutoff = NULL,  # Not currently used. Labels above this cutoff are drawn\n                        y_lab_cutoff = NULL,  # Labels above this cutoff are drawn\n                        x_node_labs = NULL,   # Not currently used.\n                        y_node_labs = NULL,   # vector of names to label as internal nodes. y_node_labs <- c('fabaceae', 'betulaceae', 'rosaceae', 'myrtaceae', 'asteraceae', 'poaceae', 'pinaceae')\n                        bubble_scale = 5,     # multiplier for bubble size\n                        bubble_transform = NULL) {     # select tranformation for bubble scaling\n\n  ## How many tips and how big is interaction matrix\n  ny <- length(y_tree$tip.label)\n  nx <- length(x_tree$tip.label)\n  nmat <- matrix(0,\n                 nrow = ny,\n                 ncol = nx,\n                 dimnames = list(y_tree$tip.label,\n                                 x_tree$tip.label))\n\n  ## Save another copy for plotting\n  mat <- nmat\n\n  ## fill with 1's if a count of interactions is desired response\n  if(count) { response <- rep(1, length(y_key)) }\n\n  ## data.frame combining x, y, and response.\n  ## create a new combination column.\n  full_dat <-\n    data.frame(y_key, x_key, response) %>%\n    dplyr::mutate(combo = paste(y_key, x_key, sep=' X '))\n\n  ## Take the long form and compress into summary stats\n  ## grouped by the combination column\n  group_response <-\n    full_dat %>%\n    dplyr::group_by(combo) %>%\n    dplyr::summarize(mean_response = mean(response),\n                     max_response = max(response),\n                     min_response = min(response))\n\n  ## Lookup table for the number of combinations\n  ## not sure why count won't work but whatever.\n  combinations <- full_dat$combo %>% table %>% sort %>% rev\n  group_response$n_combo <- combinations[group_response$combo]\n\n  ## fill in matrix\n  for (i in 1:nrow(group_response)) {\n    y_x <- strsplit(group_response$combo[i], split=' X ')[[1]]\n    if(y_x[1] %in% row.names(mat)) {\n      if(y_x[2] %in% colnames(mat)) {\n        mat[y_x[1], y_x[2]] <- group_response$mean_response[i]\n        nmat[y_x[1], y_x[2]] <- group_response$n_combo[i]\n      }\n    }\n  }\n\n\n  # ---------------------------\n\n\n  ########## STOPPED HERE.\n\n\n  ## Size of plotted bubbles. Scaled by the multipier and transform input\n  if(!is.null(bubble_transform)) {\n    if(bubble_transform == 'log') {\n      tr <- function(x) x %>% abs %>% log\n    } else if(bubble_transform == 'sqrt') {\n      tr <- function(x) x %>% abs %>% sqrt\n    } else {\n      print('Check bubble_transform shoice')\n      tr <- function(x) x\n    }\n  } else { tr <- function(x) x }\n\n  if(count) {\n    mat_cex <-\n      (nmat+1) %>%\n      log %>% tr %>%\n      magrittr::multiply_by(bubble_scale)\n  } else {\n    mat_cex <-\n      (abs(mat)+1) %>%\n      log %>% tr %>%\n      magrittr::multiply_by(bubble_scale)\n  }\n\n  ## Positive or negetive for plotting.\n  ## set up test? Maybe not necessary\n  mat_pn <- mat\n  mat_pn[mat > 0] <- 1\n  mat_pn[mat < 0] <- -1\n\n  ## Grouped response values for marginal barplots.\n  ## Ordered by the names in the matrix.\n  y_ave_resp <-\n    full_dat %>%\n    dplyr::group_by(y_key) %>%     # name of taxon\n    dplyr::summarize(\n      ave_resp_per_y = mean(response),\n      ave_resp_per_y_abs = mean(response) %>% abs) %>%\n    data.frame %>%\n    magrittr::set_rownames(.[, 1]) %>%    # stupid.\n    .[dimnames(mat)[[1]], ]     # reorder to match mat\n  y_ave_resp$ave_resp <- NULL   # get mean of means\n  for(i in 1:nrow(mat)) {\n    mr <- mat[i, ] %>% .[which(. != 0)] %>% mean\n    y_ave_resp$ave_resp[i] <- mr\n  }\n  y_ave_resp$count_resp <- rowSums(nmat)\n\n  ## add optional values for barplots.\n  if(!is.null(response_y_bars)) {\n    if(all(row.names(response_y_bars) %in% row.names(y_ave_resp))) {\n      y_ave_resp$response_y_bars <-\n        response_y_bars[row.names(response_y_bars), 1]\n    } else {\n      stop('Check the format of response_y_bars')\n    }\n  }\n\n  ## get absolute value and pos/neg coloring indicator\n  y_ave_resp %<>%\n    dplyr::mutate(\n      ave_resp_abs = abs(ave_resp),\n      y_pn = dplyr::case_when(\n        ave_resp > 0 ~ 1,\n        ave_resp < 0 ~ -1,\n        ave_resp == 0 ~ 0)) %>%\n    magrittr::set_rownames(.[, 1])\n\n  ## get abs and pn for optional bar response\n  if(!is.null(response_y_bars)) {\n    y_ave_resp %<>%\n      dplyr::mutate(\n        bars_resp_abs = abs(response_y_bars),\n        y_pn = dplyr::case_when(\n          .$response_y_bars > 0 ~ 1,\n          .$response_y_bars < 0 ~ -1,\n          .$response_y_bars == 0 ~ 0)) %>%\n      magrittr::set_rownames(.[, 1])\n\n  }\n\n\n\n  ## Same for the x-axis tree\n  x_ave_resp <-\n    full_dat %>%\n    dplyr::group_by(x_key) %>%\n    dplyr::summarize(ave_resp_per_x = mean(response),\n                     ave_resp_abs_per_x = mean(response) %>% abs) %>%\n    data.frame %>%\n    magrittr::set_rownames(.[, 1]) %>%\n    .[dimnames(mat)[[2]], ]\n  x_ave_resp$ave_resp <- NULL\n  for(i in 1:ncol(mat)) {\n    mc <- mat[, i] %>% .[which(. != 0)] %>% mean\n    x_ave_resp$ave_resp[i] <- mc\n  }\n  x_ave_resp$count_resp <- colSums(nmat)\n\n  ## add optional values for barplots.\n  if(!is.null(response_x_bars)) {\n    if(all(row.names(response_x_bars) %in% row.names(x_ave_resp))) {\n      x_ave_resp$response_x_bars <-\n        response_x_bars[row.names(response_x_bars), 1]\n    } else {\n      stop('Check the format of response_x_bars')\n    }\n  }\n\n  x_ave_resp %<>%\n    dplyr::mutate(\n      ave_resp_abs = abs(ave_resp),\n      x_pn = dplyr::case_when(\n        ave_resp > 0 ~ 1,\n        ave_resp < 0 ~ -1,\n        ave_resp == 0 ~ 0)) %>%\n    magrittr::set_rownames(.[, 1])\n\n  ## get abs and pn for optional bar response\n  if(!is.null(response_x_bars)) {\n    x_ave_resp %<>%\n      dplyr::mutate(\n        bars_resp_abs = abs(response_x_bars),\n        x_pn = dplyr::case_when(\n          .$response_x_bars > 0 ~ 1,\n          .$response_x_bars < 0 ~ -1,\n          .$response_x_bars == 0 ~ 0)) %>%\n      magrittr::set_rownames(.[, 1])\n  }\n\n  ## Put these categories into the __ave_resp data.frames.\n  ## will be used for colors during plotting.\n  if(!is.null(response_type)) {\n    rt <- table(response_type)\n    ## Lazy for now. if someone needs more than 2, fix it.\n    if(dim(rt) > 2) {\n      stop('Response currently can only have 2 categories.\n         If this is not enough, contact the author.')\n    }\n\n    ## creat lookup tables\n    xt <- table(response_type, x_key)\n    yt <- table(response_type, y_key)\n\n    ## Fill in response type column for x\n    x_ave_resp$type <- NULL\n    for(i in 1:nrow(x_ave_resp)) {\n      xi <- x_ave_resp$x_key[i]\n      if(all(xt[, xi] > 0)) {\n        x_ave_resp$type[i] <- 'Both'\n      } else {\n        x_ave_resp$type[i] <- row.names(xt)[which(xt[, xi] != 0)]\n      }\n    }\n    ## sort factor levels for color assignment\n    if(any(x_ave_resp$type == 'Both')) {\n      x_ave_resp$type %<>% factor(levels = c(names(rt), 'Both'))\n    } else x_ave_resp$type %<>% factor\n\n    ## Fill in response type column for y\n    y_ave_resp$type <- NULL\n    for(i in 1:nrow(y_ave_resp)) {\n      yi <- y_ave_resp$y_key[i]\n      if(all(yt[, yi] > 0)) {\n        y_ave_resp$type[i] <- 'Both'\n      } else {\n        y_ave_resp$type[i] <- row.names(yt)[which(yt[, yi] != 0)]\n      }\n    }\n    ## sort factor levels for color assignment\n    if(any(y_ave_resp$type == 'Both')) {\n      y_ave_resp$type %<>% factor(levels = c(names(rt), 'Both'))\n    } else y_ave_resp$type %<>% factor\n\n    ## Output for user.\n    ## This should help to supply color arguments to the plotting function.\n    cat('\\n\\nThese are the x-axis categories: ')\n    print(table(x_ave_resp$type))\n    cat('\\n\\nThese are the y-axis categories: ')\n    print(table(y_ave_resp$type))\n\n  } else {\n\n    ## Fill in response type column for x\n    x_ave_resp$type <- NULL\n\n    ## Fill in response type column for y\n    y_ave_resp$type <- NULL\n\n    ## Output for user.\n    ## This should help to supply color arguments to the plotting function.\n    cat('\\n\\nNo categories were supplied for response_type. Moving on.  ')\n  }\n\n  ## Select top n to name on barplots based on response cutoff.\n  ## Those unplotted are acutally just plotted as ''\n  if(!is.null(x_lab_cutoff)) {\n    x_ave_resp$x_lab <- x_ave_resp$x_key %>% as.character\n    x_ave_resp$x_lab[x_ave_resp$ave_resp_abs < x_lab_cutoff] <- ''\n  } else { x_ave_resp$x_lab <- '' }\n\n  ## Same for y\n  if(!is.null(y_lab_cutoff)) {\n    y_ave_resp$y_lab <- y_ave_resp$y_key %>% as.character\n    y_ave_resp$y_lab[which(y_ave_resp$ave_resp_abs < y_lab_cutoff)] <- ''\n  } else { y_ave_resp$y_lab <- '' }\n\n  ## Select a few internal clades to label.\n  if(!is.null(x_node_labs)) {\n    x_these <-\n      x_node_labs %>%\n      paste(collapse='|') %>%\n      grep(., x_tree$node.label)\n    x_tree$label_nodes <- rep('', x_tree$Nnode)\n    x_tree$label_nodes[x_these] <-\n      sapply(x_tree$node.label[x_these], FUN=simple_cap)\n  }\n\n  if(!is.null(y_node_labs)) {\n    y_these <-\n      y_node_labs %>%\n      paste(collapse='|') %>%\n      grep(., y_tree$node.label)\n    y_tree$label_nodes <- rep('', y_tree$Nnode)\n    y_tree$label_nodes[y_these] <-\n      sapply(y_tree$node.label[y_these], FUN=simple_cap)\n  }\n\n\n  OUT <- list(x_tree = x_tree,\n              y_tree = y_tree,\n              x_ave_resp = x_ave_resp,\n              y_ave_resp = y_ave_resp,\n              mat = mat,\n              nmat = nmat,\n              mat_cex = mat_cex,\n              mat_pn = mat_pn,\n              full_dat = full_dat,\n              group_response = group_response,\n              count = count,\n              bubble_transform = bubble_transform)\n  return(OUT)\n\n\n}\n\n\n",
    "created" : 1494056269918.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "554385313",
    "id" : "3537BCD2",
    "lastKnownWriteTime" : 1495262767,
    "last_content_update" : 1495262767662,
    "path" : "~/Dropbox (Personal)/R_stuff/dualingTrees-pkg/dualingTrees/R/input_trees.R",
    "project_path" : "R/input_trees.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}